<#
.SYNOPSIS
    A comprehensive system inventory and compliance reporting tool.
.DESCRIPTION
    The NPC System Inspector scans a Windows machine to gather detailed hardware, software, security,
    and configuration information, then compiles it into a professional, easy-to-read HTML report.
    It can be run interactively or automated with command-line parameters.
.PARAMETER CollectedBy
    Specifies the name of the person running the report. If not provided, the script will prompt for it.
.PARAMETER ShowReport
    If specified, the script will automatically open the generated HTML report in the default browser.
.PARAMETER Silent
    If specified, the script will suppress all console progress messages.
.EXAMPLE
    .\npc-system-inspector.ps1 -CollectedBy "Admin" -ShowReport
    Runs the script, sets the collector's name to "Admin", and opens the report automatically.
.VERSION 4.4.0.0
.COMPANY NPC Tech
.PRODUCT NPC System Inspector
.COPYRIGHT (c) 2024 Moslemul Hakim. All rights reserved.
.NOTES
    Author: Moslemul Hakim
    Date: 2024-06-30
    Changelog:
     v4.4
       - Updated the HTML footer to display the logo to the left of the "Generated by" text
         using a flexbox layout for better alignment.
     v4.3
       - Restored the "System Summary" header for clarity but kept the section static (non-collapsible).
     v4.2
       - Modified the HTML report layout: removed the main header title, made the System Summary
         static, and added the company logo to the footer.
     v4.1
       - Removed the activation key system and added command-line parameters for automation.
===========================
#>

param(
    [string]$CollectedBy,
    [switch]$ShowReport,
    [switch]$Silent
)

#region SCRIPT PREPARATION AND CHECKS

# Function to write messages to the console unless in silent mode
function Write-VerboseMessage {
    param([string]$Message, [string]$Color = "White")
    if (-not $Silent) {
        Write-Host $Message -ForegroundColor $Color
    }
}

# 1. --- Administrator Check ---
if (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Write-Warning "This script requires Administrator privileges to gather all system details."
    Write-Warning "Please re-run this script from an elevated PowerShell prompt (Run as Administrator)."
    Read-Host "Press Enter to exit..."
    exit
}

# 2. --- Define Script Directory and Report File ---
try {
    $scriptDir = $PSScriptRoot
    if ([string]::IsNullOrWhiteSpace($scriptDir)) { throw "PSScriptRoot is empty." }
}
catch {
    $scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
}
if (-not $scriptDir) { $scriptDir = "." }

# 3. --- Get Collector's Name ---
# Use the parameter if provided, otherwise prompt the user.
if ([string]::IsNullOrWhiteSpace($CollectedBy)) {
    do {
        $CollectedBy = Read-Host "Enter the name of the person collecting this report"
    } while ([string]::IsNullOrWhiteSpace($CollectedBy))
}

$reportDate = Get-Date -Format 'yyyy-MM-dd HH:mm'
Write-VerboseMessage "Starting PC inventory collection for user: $CollectedBy" -Color Green

#endregion

#region HELPER FUNCTIONS

# Function to format file sizes from bytes into a human-readable format.
function Fmt-Size ($bytes) {
    if ($null -eq $bytes) { return 'N/A' }
    if ($bytes -ge 1TB) { "{0:N2} TB" -f ($bytes/1TB) }
    elseif ($bytes -ge 1GB) { "{0:N2} GB" -f ($bytes/1GB) }
    elseif ($bytes -ge 1MB) { "{0:N2} MB" -f ($bytes/1MB) }
    elseif ($bytes -ge 1KB) { "{0:N2} KB" -f ($bytes/1KB) }
    else { "$bytes B" }
}

# Function to interpret RAM type codes into human-readable strings.
function Get-RamTypeStr ($type, $smbios) {
    $v = if ($smbios -and $smbios -gt 2) { $smbios } else { $type }
    switch ($v) {
        0 { "Unknown" }; 1 { "Other" }; 2 { "DRAM" }; 3 { "Synchronous DRAM" }; 4 { "Cache DRAM" }; 5 { "EDO" };
        6 { "EDRAM" }; 7 { "VRAM" }; 8 { "SRAM" }; 9 { "RAM" }; 10 { "ROM" }; 11 { "Flash" }; 12 { "EEPROM" };
        13 { "FEPROM" }; 14 { "EPROM" }; 15 { "CDRAM" }; 16 { "3DRAM" }; 17 { "SDRAM" }; 18 { "SGRAM" };
        19 { "RDRAM" }; 20 { "DDR" }; 21 { "DDR2" }; 22 { "DDR2 FB-DIMM" }; 24 { "DDR3" }; 25 { "FBD2" };
        26 { "DDR4" }; 27 { "LPDDR" }; 28 { "LPDDR2" }; 29 { "LPDDR3" }; 30 { "LPDDR4" }; 31 { "Logical non-volatile device" };
        32 { "HBM" }; 33 { "HBM2" }; 34 { "DDR5" }; 35 { "LPDDR5" }; default { "Undefined ($v)" }
    }
}

# Function to determine the class of an IPv4 address.
function Get-IPv4Class ($ip) {
    if ([string]::IsNullOrWhiteSpace($ip)) { return "N/A" }
    $firstOctet = [int]($ip.Split('.')[0])
    if ($firstOctet -ge 1 -and $firstOctet -le 126) { return "A" }
    elseif ($firstOctet -ge 128 -and $firstOctet -le 191) { return "B" }
    elseif ($firstOctet -ge 192 -and $firstOctet -le 223) { return "C" }
    elseif ($firstOctet -ge 224 -and $firstOctet -le 239) { return "D (Multicast)" }
    elseif ($firstOctet -ge 240 -and $firstOctet -le 254) { return "E (Experimental)" }
    else { return "N/A" }
}

# Function to categorize storage drive types.
function Get-StorageTypeStr ($drive, $physDisk) {
    if ($drive.InterfaceType -eq "USB") { return "USB Drive" }
    if ($drive.MediaType -eq "Removable Media") { return "Removable Media / Memory Card" }
    if ($physDisk) {
        switch ($physDisk.MediaType) {
            3 { return "HDD (Hard Disk Drive)" }
            4 { return "SSD (Solid State Drive)" }
            5 { return "SCM (Storage Class Memory)" }
        }
    }
    # Fallback if MSFT_PhysicalDisk fails. Try to infer from model name.
    if ($drive.Model -like "*SSD*") { return "SSD (Inferred)" }
    if ($drive.MediaType -like "*Fixed*") { return "Fixed Disk (Type Unknown)"}
    return $drive.MediaType
}


#endregion

#region DATA COLLECTION

# Wrap data collection in a try/catch block to handle any unexpected errors gracefully.
try {
    # --- Gather all system information using CIM instances ---
    Write-VerboseMessage "Collecting hardware and system data..."
    $cs      = Get-CimInstance Win32_ComputerSystem
    $os      = Get-CimInstance Win32_OperatingSystem
    $base    = Get-CimInstance Win32_BaseBoard
    $bios    = Get-CimInstance Win32_BIOS
    $cpu     = Get-CimInstance Win32_Processor
    $gpu     = Get-CimInstance Win32_VideoController
    $mem     = Get-CimInstance Win32_PhysicalMemory
    $logical = Get-CimInstance Win32_LogicalDisk | Where-Object { $_.DriveType -ne 5 } # Exclude CD-ROM drives
    $drives  = Get-CimInstance Win32_DiskDrive
    $netadp  = Get-CimInstance Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled }
    $users   = Get-CimInstance Win32_UserAccount | Where-Object { $_.LocalAccount -eq $true }
    
    # --- Advanced Data Collection Functions ---
    Write-VerboseMessage "Collecting security and status information..."
    $bitlocker = Get-BitLockerVolume -ErrorAction SilentlyContinue
    $tpm = Get-CimInstance -Namespace "Root\CIMv2\Security\MicrosoftTpm" -Class Win32_Tpm -ErrorAction SilentlyContinue
    $errors = Get-WinEvent -FilterHashtable @{LogName='System'; Level=1,2; StartTime=(Get-Date).AddDays(-7)} -MaxEvents 20 -ErrorAction SilentlyContinue | Select-Object TimeCreated, Id, Message
    $mappedDrives = Get-CimInstance Win32_LogicalDisk | Where-Object { $_.DriveType -eq 4 }
    $sharedFolders = Get-CimInstance Win32_Share -ErrorAction SilentlyContinue
    $startupPrograms = Get-CimInstance -ClassName Win32_StartupCommand | Select-Object Name, Command, Location, User
    
    # Pre-load all physical disk health information into a hash table keyed by serial number for the most reliable lookup.
    $physicalDisksBySerial = @{}
    Get-CimInstance -Namespace Root\Microsoft\Windows\Storage -ClassName MSFT_PhysicalDisk -ErrorAction SilentlyContinue | ForEach-Object {
        if (-not [string]::IsNullOrWhiteSpace($_.SerialNumber)) {
            # Trim whitespace from serial numbers as it can sometimes have padding
            $physicalDisksBySerial[$_.SerialNumber.Trim()] = $_
        }
    }

    $batteryDetails = Get-CimInstance -ClassName Win32_Battery -ErrorAction SilentlyContinue | ForEach-Object {
        $health = if ($_.DesignCapacity -gt 0) { [math]::Round(($_.FullChargedCapacity / $_.DesignCapacity) * 100, 2) } else { "N/A" }
        [PSCustomObject]@{ DeviceID=$_.DeviceID; Status=$_.Status; DesignedCapacity_mWh=$_.DesignCapacity; FullChargeCapacity_mWh=$_.FullChargedCapacity; EstimatedChargeRemaining_Percent=$_.EstimatedChargeRemaining; BatteryHealth_Percent=$health }
    }

    $winActivation = Get-CimInstance SoftwareLicensingProduct -Filter "ApplicationID='55c92734-d682-4d71-983e-d6ec3f16059f' and LicenseStatus=1" -ErrorAction SilentlyContinue | Select-Object -First 1

    $updateStatus = try {
        $updateSession = New-Object -ComObject Microsoft.Update.Session
        $pendingUpdates = $updateSession.CreateUpdateSearcher().Search("IsInstalled=0").Updates.Count
        $rebootPending = (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired")
        [PSCustomObject]@{ PendingUpdates = $pendingUpdates; RebootPending = if ($rebootPending) { "Yes" } else { "No" } }
    } catch {
        [PSCustomObject]@{ PendingUpdates = "Error"; RebootPending = "Error" }
    }

    $avProducts = Get-CimInstance -Namespace "root\SecurityCenter2" -Class AntiVirusProduct -ErrorAction SilentlyContinue
    $fwProducts = Get-CimInstance -Namespace "root\SecurityCenter2" -Class FirewallProduct -ErrorAction SilentlyContinue
    $uacEnabled = (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System).EnableLUA
    $firewallStatus = ($fwProducts.DisplayName | Where-Object { $_ }) -join ", "
    if ([string]::IsNullOrWhiteSpace($firewallStatus)) {
        try {
            $fwProfiles = Get-NetFirewallProfile | Where-Object { $_.Enabled -eq 'True' }
            $firewallStatus = if ($fwProfiles) { "Windows Defender Firewall ({0} profile(s) active)" -f ($fwProfiles.Name -join ', ') } else { "No active firewall detected." }
        } catch { $firewallStatus = "Unknown (Could not query profiles)" }
    }
    $securityInfo = [PSCustomObject]@{ Antivirus = ($avProducts.DisplayName | Where-Object { $_ }) -join ", "; Firewall = $firewallStatus; UAC = if ($uacEnabled -eq 1) { "Enabled" } else { "Disabled" } }
    
    # --- Definitive Boot Mode and Secure Boot Check ---
    $bootMode = "Unknown" # Default value
    $isUEFI = $false
    try {
        $firmware = Get-CimInstance -ClassName Win32_BIOS -Property SMBIOSBIOSVersion -ErrorAction Stop
        $isUEFI = (Test-Path "$env:windir\Panther\setupact.log") -and ((Select-String -Path "$env:windir\Panther\setupact.log" -Pattern 'Callback_BootEnvironmentDetect: Detected boot environment: UEFI').Length -gt 0)
    } catch {}

    if ($isUEFI) {
        try {
            if (Get-SecureBootUEFI -ErrorAction Stop) { $bootMode = "UEFI (Secure Boot Enabled)" } else { $bootMode = "UEFI (Secure Boot Disabled)" }
        } catch {
            $bootMode = "UEFI (Secure Boot state could not be determined)"
        }
    } else {
        $bootMode = "Legacy BIOS"
    }
    $biosSecurity = [PSCustomObject]@{ BootMode = $bootMode; Virtualization = if ($cpu.VirtualizationFirmwareEnabled) { "Enabled in Firmware" } else { "Disabled in Firmware" } }


    $uptime = (Get-Date) - $os.LastBootUpTime
    $systemUptime = "$([int]$uptime.TotalDays) days, $($uptime.Hours) hours, $($uptime.Minutes) minutes"
    $printers = Get-CimInstance Win32_Printer -ErrorAction SilentlyContinue
    $services = Get-Service | Where-Object { $_.Status -eq 'Running' -and (Get-CimInstance Win32_Service -Filter "Name='$($_.Name)'").PathName -notlike '*\Windows\*' } | Select-Object DisplayName, Name, Status

    Write-VerboseMessage "Collecting installed software list (this might be slow)..."
    $softwareKeys = @("HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*", "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*", "HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*")
    $i = 0
    $allApps = Get-ItemProperty $softwareKeys -ErrorAction SilentlyContinue
    $totalApps = $allApps.Count
    $installedSoftware = $allApps | ForEach-Object {
        $i++
        if (-not $Silent) {
            Write-Progress -Activity "Gathering Installed Software" -Status "Processing item $i of $totalApps..." -PercentComplete (($i / $totalApps) * 100)
        }
        if ($_.DisplayName -and !$_.SystemComponent -and $_.DisplayName -notlike 'Update for*') { $_ }
    } | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | Sort-Object DisplayName -Unique
        
} catch {
    Write-Error "A critical error occurred during data collection: $($_.Exception.Message)"; Read-Host "Press Enter to exit..."; exit
}

Write-VerboseMessage "Data collection complete. Generating HTML report..." -Color Green

#endregion

#region HTML REPORT GENERATION

# Define the filename for the report.
$reportFileName = "$($cs.Name)_PC_Full_Inventory_Report.html"
$outfile = Join-Path $scriptDir $reportFileName

# --- HTML Header and CSS/JS Styling ---
$htmlHeader = @"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PC Full Inventory Report: $($cs.Name)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #f0f2f5; color: #1c1e21; margin: 0; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: #fff; border: 1px solid #dddfe2; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 25px; }
        h1 { text-align: center; color: #1877f2; margin-bottom: 25px; font-weight: 600; border-bottom: 2px solid #1877f2; padding-bottom: 15px;}
        h2 { display: flex; align-items: center; font-size: 1.4em; color: #1877f2; border-bottom: 1px solid #ccd0d5; margin-top: 30px; padding-bottom: 8px; }
        h2.collapsible { cursor: pointer; user-select: none; }
        h2 .arrow { display: inline-block; width: 0; height: 0; margin-right: 10px; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid #1877f2; transition: transform 0.2s ease-in-out; }
        h2.collapsed .arrow { transform: rotate(-90deg); }
        table { border-collapse: collapse; width: 100%; margin: 15px 0; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        th, td { border: 1px solid #dddfe2; padding: 10px 12px; text-align: left; font-size: 0.95em; vertical-align: top; word-break: break-all; }
        th { background: #f5f6f7; color: #4b4f56; font-weight: 600; }
        .summary-table th { width: 200px; }
        .summary-table { margin-top: 25px; }
        .footer { display: flex; justify-content: center; align-items: center; color: #606770; margin-top: 30px; font-size: 0.9em; }
        .footer img { height: 40px; margin-right: 15px; }
        .footer a { color: #1877f2; text-decoration: none; }
        .hidden { display: none; }
    </style>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('h2.collapsible').forEach(function(header) {
                const arrow = document.createElement('span');
                arrow.className = 'arrow';
                header.insertBefore(arrow, header.firstChild);

                header.addEventListener('click', function() {
                    this.classList.toggle('collapsed');
                    let content = this.nextElementSibling;
                    while(content && content.tagName !== 'H2') {
                        content.classList.toggle('hidden');
                        content = content.nextElementSibling;
                    }
                });
            });
        });
    </script>
</head>
<body>
<div class="container">
    <h1>System Specification and Compliance Report</h1>
"@

# --- Report Body ---
$htmlBody = ""

# Summary Section (now static, not collapsible)
$htmlBody += "<h2>System Summary</h2>"
$htmlBody += "<table class='summary-table'>"
$htmlBody += "<tr><th>Computer Name</th><td>$($cs.Name)</td></tr>"
$htmlBody += "<tr><th>Operating System</th><td>$($os.Caption) ($($os.OSArchitecture))</td></tr>"
$htmlBody += "<tr><th>System Model</th><td>$($cs.Manufacturer) $($cs.Model)</td></tr>"
$htmlBody += "<tr><th>Processor</th><td>$($cpu.Name)</td></tr>"
$htmlBody += "<tr><th>Total RAM</th><td>$(Fmt-Size $cs.TotalPhysicalMemory)</td></tr>"
$htmlBody += "<tr><th>Graphics</th><td>$(($gpu | Select-Object -ExpandProperty Name) -join ', ')</td></tr>"
$htmlBody += "<tr><th>System Uptime</th><td>$systemUptime</td></tr>"
$htmlBody += "<tr><th>Report Date</th><td>$reportDate</td></tr>"
$htmlBody += "<tr><th>Collected By</th><td>$CollectedBy</td></tr>"
$htmlBody += "</table>"

# Operating System
$htmlBody += "<h2 class='collapsible'>Operating System</h2><table>"
$htmlBody += "<tr><th>OS Name</th><td>$($os.Caption)</td></tr>"
$htmlBody += "<tr><th>Version</th><td>$($os.Version)</td></tr>"
$htmlBody += "<tr><th>Architecture</th><td>$($os.OSArchitecture)</td></tr>"
$htmlBody += "<tr><th>Install Date</th><td>$($os.InstallDate.ToString('yyyy-MM-dd HH:mm'))</td></tr>"
$htmlBody += "<tr><th>Last Boot Time</th><td>$($os.LastBootUpTime.ToString('yyyy-MM-dd HH:mm'))</td></tr>"
$htmlBody += "<tr><th>Windows Activation</th><td>$($winActivation.Description)</td></tr>"
$htmlBody += "</table>"

# Motherboard & BIOS
$htmlBody += "<h2 class='collapsible'>Motherboard & BIOS</h2><table>"
$htmlBody += "<tr><th>Manufacturer</th><td>$($base.Manufacturer)</td></tr>"
$htmlBody += "<tr><th>Product</th><td>$($base.Product)</td></tr>"
$htmlBody += "<tr><th>Serial Number</th><td>$($base.SerialNumber)</td></tr>"
$htmlBody += "<tr><th>BIOS Version</th><td>$($bios.SMBIOSBIOSVersion)</td></tr>"
$htmlBody += "<tr><th>Boot Mode</th><td>$($biosSecurity.BootMode)</td></tr>"
$htmlBody += "<tr><th>Virtualization</th><td>$($biosSecurity.Virtualization)</td></tr>"
$htmlBody += "</table>"

# CPU
$htmlBody += "<h2 class='collapsible'>Processor (CPU)</h2><table>"
$htmlBody += "<tr><th>Name</th><td>$($cpu.Name)</td></tr>"
$htmlBody += "<tr><th>Cores / Logical Processors</th><td>$($cpu.NumberOfCores) / $($cpu.NumberOfLogicalProcessors)</td></tr>"
$htmlBody += "<tr><th>Max Speed</th><td>$($cpu.MaxClockSpeed) MHz</td></tr>"
$htmlBody += "</table>"

# Memory (RAM)
$htmlBody += "<h2 class='collapsible'>Memory (RAM)</h2><table><tr><th>Manufacturer</th><th>Part Number</th><th>Size</th><th>Speed</th><th>Type</th></tr>"
foreach ($m in $mem) {
    $typeStr = Get-RamTypeStr $m.MemoryType $m.SMBIOSMemoryType
    $htmlBody += "<tr><td>$($m.Manufacturer)</td><td>$($m.PartNumber)</td><td>$(Fmt-Size $m.Capacity)</td><td>$($m.Speed) MHz</td><td>$typeStr</td></tr>"
}
$htmlBody += "</table>"

# Storage
$htmlBody += "<h2 class='collapsible'>Storage (Drives)</h2><table><tr><th>Model</th><th>Category</th><th>Size</th><th>Interface</th><th>Health</th><th>Operational Status</th></tr>"
foreach ($d in $drives) {
    $physDisk = $null
    if (-not [string]::IsNullOrWhiteSpace($d.SerialNumber)) {
        $physDisk = $physicalDisksBySerial[$d.SerialNumber.Trim()]
    }
    
    $driveCategory = Get-StorageTypeStr -drive $d -physDisk $physDisk
    
    $health = "N/A"
    $opStatus = "N/A"

    if ($physDisk) {
        $opStatus = $physDisk.OperationalStatus -join ", "
        switch ($physDisk.HealthStatus) { 
            1 {$health = "Healthy"}; 
            2 {$health = "Warning"}; 
            3 {$health = "Unhealthy"}; 
            default {$health = "Unknown"} 
        }
    }
    
    $htmlBody += "<tr><td>$($d.Model)</td><td>$driveCategory</td><td>$(Fmt-Size $d.Size)</td><td>$($d.InterfaceType)</td><td>$health</td><td>$opStatus</td></tr>"
}
$htmlBody += "</table>"
$htmlBody += "<h3 class='collapsible'>Disk Partitions</h3><table><tr><th>Drive</th><th>Label</th><th>File System</th><th>Total Size</th><th>Free Space</th><th>% Free</th></tr>"
foreach ($l in $logical) {
    $percentFree = if ($l.Size -gt 0) { [math]::Round(($l.FreeSpace / $l.Size) * 100, 2) } else { 0 }
    $htmlBody += "<tr><td>$($l.DeviceID)</td><td>$($l.VolumeName)</td><td>$($l.FileSystem)</td><td>$(Fmt-Size $l.Size)</td><td>$(Fmt-Size $l.FreeSpace)</td><td>$percentFree %</td></tr>"
}
$htmlBody += "</table>"

# Network
$htmlBody += "<h2 class='collapsible'>Network Adapters</h2><table><tr><th>Adapter</th><th>IPv4</th><th>Class</th><th>IPv6</th><th>Subnet</th><th>Gateway</th><th>MAC Address</th><th>DNS Servers</th><th>DHCP Server</th></tr>"
foreach ($n in $netadp) {
    $ipv4 = ($n.IPAddress | Where-Object { $_ -match '^\d+\.\d+\.\d+\.\d+$' } | Select-Object -First 1)
    $ipv6 = ($n.IPAddress | Where-Object { $_ -like '*:*' } | Select-Object -First 1)
    $htmlBody += "<tr><td>$($n.Description)</td><td>$ipv4</td><td>$(Get-IPv4Class $ipv4)</td><td>$ipv6</td><td>$(($n.IPSubnet | Select-Object -First 1))</td><td>$(($n.DefaultIPGateway | Select-Object -First 1))</td><td>$($n.MACAddress)</td><td>$(($n.DNSServerSearchOrder -join ', '))</td><td>$($n.DHCPServer)</td></tr>"
}
$htmlBody += "</table>"

# Graphics & Displays
$htmlBody += "<h2 class='collapsible'>Graphics (GPU) & Displays</h2><table><tr><th>Name</th><th>Adapter RAM</th><th>Driver Version</th><th>Current Resolution</th></tr>"
foreach ($g in $gpu) {
    $htmlBody += "<tr><td>$($g.Name)</td><td>$(Fmt-Size $g.AdapterRAM)</td><td>$($g.DriverVersion)</td><td>$($g.CurrentHorizontalResolution) x $($g.CurrentVerticalResolution)</td></tr>"
}
$htmlBody += "</table>"

# Security Status
$htmlBody += "<h2 class='collapsible'>Security Status</h2><table>"
$htmlBody += "<tr><th>Antivirus</th><td>$($securityInfo.Antivirus)</td></tr>"
$htmlBody += "<tr><th>Firewall</th><td>$($securityInfo.Firewall)</td></tr>"
$htmlBody += "<tr><th>User Account Control (UAC)</th><td>$($securityInfo.UAC)</td></tr>"
$htmlBody += "<tr><th>Pending Windows Updates</th><td>$($updateStatus.PendingUpdates)</td></tr>"
$htmlBody += "<tr><th>Reboot Pending</th><td>$($updateStatus.RebootPending)</td></tr>"
$htmlBody += "<tr><th>BitLocker Volumes</th><td>"
if ($bitlocker.Count -gt 0) { $bitlocker | ForEach-Object { $htmlBody += "$($_.MountPoint) ($($_.ProtectionStatus)); " } } else { $htmlBody += "None" }
$htmlBody += "</td></tr>"
$htmlBody += "<tr><th>TPM Present / Version</th><td>"
if ($tpm) { $htmlBody += "Yes / $($tpm.SpecVersion)" } else { $htmlBody += "No" }
$htmlBody += "</td></tr></table>"

# Battery
$htmlBody += "<h2 class='collapsible'>Battery Health</h2>"
if ($batteryDetails) {
    $htmlBody += "<table><tr><th>Device</th><th>Health</th><th>Designed Capacity</th><th>Full Charge Capacity</th><th>Current Charge</th><th>Status</th></tr>"
    foreach ($b in $batteryDetails) { $htmlBody += "<tr><td>$($b.DeviceID)</td><td>$($b.BatteryHealth_Percent)%</td><td>$($b.DesignedCapacity_mWh) mWh</td><td>$($b.FullChargeCapacity_mWh) mWh</td><td>$($b.EstimatedChargeRemaining_Percent)%</td><td>$($b.Status)</td></tr>" }
    $htmlBody += "</table>"
} else {
    $htmlBody += "<p>No battery detected on this system.</p>"
}

# Local Users
$htmlBody += "<h2 class='collapsible'>Local User Accounts</h2><table><tr><th>Username</th><th>Full Name</th><th>Enabled</th><th>Password Changeable</th></tr>"
foreach ($u in $users) { $htmlBody += "<tr><td>$($u.Name)</td><td>$($u.FullName)</td><td>$(!$u.Disabled)</td><td>$($u.PasswordChangeable)</td></tr>" }
$htmlBody += "</table>"

# Mapped Network Drives
$htmlBody += "<h2 class='collapsible'>Mapped Network Drives</h2>"
if ($mappedDrives) {
    $htmlBody += "<table><tr><th>Drive Letter</th><th>Remote Path (NAS / Share)</th></tr>"
    foreach ($md in $mappedDrives) { $htmlBody += "<tr><td>$($md.DeviceID)</td><td>$($md.ProviderName)</td></tr>" }
    $htmlBody += "</table>"
} else {
    $htmlBody += "<p>No mapped network drives found.</p>"
}

# Shared Folders
$htmlBody += "<h2 class='collapsible'>Local Shared Folders</h2>"
if ($sharedFolders) {
    $htmlBody += "<table><tr><th>Share Name</th><th>Local Path</th><th>Description</th></tr>"
    foreach ($sf in $sharedFolders) { $htmlBody += "<tr><td>$($sf.Name)</td><td>$($sf.Path)</td><td>$($sf.Description)</td></tr>" }
    $htmlBody += "</table>"
} else {
    $htmlBody += "<p>No folders are being shared from this computer.</p>"
}

# Startup Programs
$htmlBody += "<h2 class='collapsible'>Startup Programs</h2>"
if ($startupPrograms) {
    $htmlBody += "<table><tr><th>Program Name</th><th>Command</th><th>Location</th><th>User</th></tr>"
    foreach ($sp in $startupPrograms) { $htmlBody += "<tr><td>$($sp.Name)</td><td>$($sp.Command)</td><td>$($sp.Location)</td><td>$($sp.User)</td></tr>" }
    $htmlBody += "</table>"
} else {
    $htmlBody += "<p>No startup programs found in common locations.</p>"
}

# Installed Printers
$htmlBody += "<h2 class='collapsible'>Installed Printers</h2><table><tr><th>Name</th><th>Driver Name</th><th>Port</th><th>Shared</th><th>Default</th></tr>"
foreach ($p in $printers) { $htmlBody += "<tr><td>$($p.Name)</td><td>$($p.DriverName)</td><td>$($p.PortName)</td><td>$($p.Shared)</td><td>$($p.Default)</td></tr>" }
$htmlBody += "</table>"

# Running Non-Microsoft Services
$htmlBody += "<h2 class='collapsible'>Running Non-Microsoft Services</h2><table><tr><th>Display Name</th><th>Service Name</th></tr>"
if ($services.Count -gt 0) { foreach ($s in $services | Sort-Object DisplayName) { $htmlBody += "<tr><td>$($s.DisplayName)</td><td>$($s.Name)</td></tr>" } } else { $htmlBody += "<tr><td colspan='2'>No running third-party services found.</td></tr>" }
$htmlBody += "</table>"

# Recent System Errors
$htmlBody += "<h2 class='collapsible'>Recent System Errors (Last 7 Days)</h2><table><tr><th>Time</th><th>Event ID</th><th>Message</th></tr>"
if ($errors.Count -gt 0) { foreach ($e in $errors) { $htmlBody += "<tr><td>$($e.TimeCreated)</td><td>$($e.Id)</td><td>$($e.Message -replace '<', '&lt;' -replace '>', '&gt;')</td></tr>" } } else { $htmlBody += "<tr><td colspan='3'>No critical system errors found in the last 7 days.</td></tr>" }
$htmlBody += "</table>"

# Installed Software
$htmlBody += "<h2 class='collapsible'>Installed Software</h2><table><tr><th>Name</th><th>Version</th><th>Publisher</th></tr>"
if ($installedSoftware.Count -gt 0) { foreach ($app in $installedSoftware) { $htmlBody += "<tr><td>$($app.DisplayName)</td><td>$($app.DisplayVersion)</td><td>$($app.Publisher)</td></tr>" } } else { $htmlBody += "<tr><td colspan='3'>Could not retrieve a list of installed software.</td></tr>" }
$htmlBody += "</table>"

# --- HTML Footer ---
$htmlFooter = @"
    <div class="footer">
        <img src="https://npc.com.bd/image/logo.png" alt="NPC Tech Logo" onerror="this.style.display='none'">
        <span>
            Generated by <a href="https://npc.com.bd/" target="_blank">NPC System Inspector v4.4</a>
            | Powered by <a href="https://www.linkedin.com/in/moslemulhakim/" target="_blank">MOSLEMUL HAKIM</a>
        </span>
    </div>
</div>
</body>
</html>
"@

# --- Combine and Save the Report ---
$finalHtml = $htmlHeader + $htmlBody + $htmlFooter
$finalHtml | Set-Content -Path $outfile -Encoding UTF8 -Force

Write-Host "Success! Inventory report saved to:" -ForegroundColor Green
Write-Host $outfile

# Optional: Automatically open the report if the -ShowReport switch is used
if ($ShowReport) {
    try {
        Invoke-Item $outfile
    } catch {
        Write-Warning "Could not automatically open the report. Please open it manually: $outfile"
    }
}

if (-not $Silent) {
    Read-Host "Press Enter to exit..."
}

#endregion
